{"title":"R pour le Big Data","markdown":{"yaml":{"title":"R pour le Big Data","format":"html","description":"Traiter des données plus volumineuses que la mémoire vive avec R","author":"Félix Marchais","date":"2025-07-30","categories":["R","Big Data"],"execute":{"eval":false,"echo":true},"draft":true},"headingText":"Big Data","containsRefs":false,"markdown":"\n\n\n## Apache Arrow et DuckDB  \n\nGrâce à Apache Arrow et Duckdb, il est possible de traiter de grands volumes de données facilement avec R. Ci-dessous, un exemple de requête sur un jeu de données de plus d'1 milliard de lignes. \\n\n\nLes données sont celles du dataset TLC Trip Record Data (https://www.nyc.gov/site/tlc/about/tlc-trip-record-data.page), et contiennent les informations de trajets de taxis new-yorkais. \\n\n\nDans cet exemple, les données de chaque mois entre janvier 2013 et avril 2025 ont été récupérées et regroupées dans un dossier appelé taxi_dataset. Ce dossier contient 147 fichiers au format .Parquet et pèse 14Go pour plus d'un milliard de lignes (le format .Parquet est un format compressé, le même jeu de données en .csv pèse environ 100Go). \\n\n\n```{r echo = TRUE, eval = FALSE, comment = FALSE, message = FALSE}\n\nlibrary(tidyverse) # Tidyverse sert à la manipulation de données\nlibrary(duckdb) # duckdb pour créer une base duckdb virtuelle\nlibrary(arrow) # Arrow pour lire des fichiers .Parquet\nlibrary(duckplyr) # Duckplyr pour utiliser dplyr avec le moteur duckdb\nlibrary(DBI) # DBI pour créer une connection à la base duckdb virtuelle\nlibrary(microbenchmark) # Pour vérifier les temps d'exécution\n\n# Créer une base duckdb virtuelle\nconn_ddb <- dbConnect(duckdb(), dbdir = \":memory:\")\n\nyellow_taxi <- conn_ddb %>% \n  tbl(\"read_parquet('D:\\\\taxi_dataset\\\\*.parquet')\" )\n# Il suffit d'indiquer le chemin vers le dossier contenant les 157 fichiers pour que {arrow} reconstitue le tout et le considère comme un seul dataset (il faut évidemment que les jeux de données suivent le même schéma)\n# Ici, yellow_taxi ne contient pas directement les données, mais une connexion au dataset.\n# on peut désormais requêter yellow_taxi comme un dataframe classique avec la grammaire de {dplyr}, sans avoir chargé les données dans la mémoire vive de R\n\nyellow %>% count()\n# 1.101.292.583 => 1 milliard de lignes\n\n# Utiliser microbenchmark() pour calculer le temps d'éxécution\nmicrobenchmark(\n  res = x <- yellow %>% \n    # filtrer les lignes\n    filter(trip_distance >=2) %>%  \n    # Créer une colonne \"year\" qui contient l'année du voyage\n    mutate(year = year(tpep_pickup_datetime)) %>% \n    # Aggréger tip_amount pour obtenir la moyenne du pourboire par nombre de passagers\n    summarize(mean_tip_amount = mean(tip_amount), .by = year) %>%\n    collect(), # Ajouter collect() pour récupérer les données\n  times = 1\n)\n# 14.2 secondes\n```\n\n\n## Spark et Hadoop  \n\nOn peut aussi se connecter à un cluster Spark, et envoyer ses requêtes depuis R avec la syntaxe de {dplyr} en utilisant {sparklyr}.","srcMarkdownNoYaml":"\n\n# Big Data  \n\n## Apache Arrow et DuckDB  \n\nGrâce à Apache Arrow et Duckdb, il est possible de traiter de grands volumes de données facilement avec R. Ci-dessous, un exemple de requête sur un jeu de données de plus d'1 milliard de lignes. \\n\n\nLes données sont celles du dataset TLC Trip Record Data (https://www.nyc.gov/site/tlc/about/tlc-trip-record-data.page), et contiennent les informations de trajets de taxis new-yorkais. \\n\n\nDans cet exemple, les données de chaque mois entre janvier 2013 et avril 2025 ont été récupérées et regroupées dans un dossier appelé taxi_dataset. Ce dossier contient 147 fichiers au format .Parquet et pèse 14Go pour plus d'un milliard de lignes (le format .Parquet est un format compressé, le même jeu de données en .csv pèse environ 100Go). \\n\n\n```{r echo = TRUE, eval = FALSE, comment = FALSE, message = FALSE}\n\nlibrary(tidyverse) # Tidyverse sert à la manipulation de données\nlibrary(duckdb) # duckdb pour créer une base duckdb virtuelle\nlibrary(arrow) # Arrow pour lire des fichiers .Parquet\nlibrary(duckplyr) # Duckplyr pour utiliser dplyr avec le moteur duckdb\nlibrary(DBI) # DBI pour créer une connection à la base duckdb virtuelle\nlibrary(microbenchmark) # Pour vérifier les temps d'exécution\n\n# Créer une base duckdb virtuelle\nconn_ddb <- dbConnect(duckdb(), dbdir = \":memory:\")\n\nyellow_taxi <- conn_ddb %>% \n  tbl(\"read_parquet('D:\\\\taxi_dataset\\\\*.parquet')\" )\n# Il suffit d'indiquer le chemin vers le dossier contenant les 157 fichiers pour que {arrow} reconstitue le tout et le considère comme un seul dataset (il faut évidemment que les jeux de données suivent le même schéma)\n# Ici, yellow_taxi ne contient pas directement les données, mais une connexion au dataset.\n# on peut désormais requêter yellow_taxi comme un dataframe classique avec la grammaire de {dplyr}, sans avoir chargé les données dans la mémoire vive de R\n\nyellow %>% count()\n# 1.101.292.583 => 1 milliard de lignes\n\n# Utiliser microbenchmark() pour calculer le temps d'éxécution\nmicrobenchmark(\n  res = x <- yellow %>% \n    # filtrer les lignes\n    filter(trip_distance >=2) %>%  \n    # Créer une colonne \"year\" qui contient l'année du voyage\n    mutate(year = year(tpep_pickup_datetime)) %>% \n    # Aggréger tip_amount pour obtenir la moyenne du pourboire par nombre de passagers\n    summarize(mean_tip_amount = mean(tip_amount), .by = year) %>%\n    collect(), # Ajouter collect() pour récupérer les données\n  times = 1\n)\n# 14.2 secondes\n```\n\n\n## Spark et Hadoop  \n\nOn peut aussi se connecter à un cluster Spark, et envoyer ses requêtes depuis R avec la syntaxe de {dplyr} en utilisant {sparklyr}."},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":false,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"decouvrir_bigdata.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.42","editor":"source","theme":"sandstone","title":"R pour le Big Data","description":"Traiter des données plus volumineuses que la mémoire vive avec R","author":"Félix Marchais","date":"2025-07-30","categories":["R","Big Data"],"draft":true},"extensions":{"book":{"multiFile":true}}}},"draft":true,"projectFormats":["html"]}